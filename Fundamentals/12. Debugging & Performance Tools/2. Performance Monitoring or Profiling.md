***
**Performance Monitoring / Profiling:** `perf`, `time`, `top`, `htop`, `vmstat`, `iostat`, `sar`, `atop`
***
***
# Linux Perf Command Guide

## Introduction

The `perf` command in Linux is a powerful tool used for performance profiling, benchmarking, and analyzing hardware and software events. It allows you to collect and interpret performance data for applications and the kernel.

## Installation

On most Linux distributions, `perf` can be installed via the package manager.

For Ubuntu/Debian:

```
sudo apt-get install linux-tools-common linux-tools-$(uname -r)
```

For CentOS/RHEL:

```
sudo yum install perf
```

## Basic Usage

The basic syntax of the perf command is:

```
perf [command] [options]
```

### 1\. perf stat

`perf stat` provides a summary of performance counters for a command.

Example:

```
perf stat ls -l
```

This will run `ls -l` and provide performance metrics such as CPU cycles, instructions, cache references, and more.

### 2\. perf record

`perf record` collects performance data and stores it in a file for later analysis.

Example:

```
perf record -g ls -l
```

This records performance data including call graphs for the `ls -l` command.

The data is stored in a file called `perf.data` by default.

### 3\. perf report

`perf report` generates a human-readable report from the data collected using `perf record`.

Example:

```
perf report
```

This will display a report with CPU usage percentages for functions and call graphs.

### 4\. perf top

`perf top` is used to view live performance statistics similar to `top` but focused on CPU usage per function.

Example:

```
perf top
```

This will display a real-time view of the functions consuming the most CPU.

### 5\. perf list

`perf list` displays all available events that can be monitored.

Example:

```
perf list
```

It shows hardware events like cycles, instructions, cache references, and software events like context switches, page faults, etc.

### 6\. perf record with specific events

You can specify events to monitor using the `-e` flag.

Example:

```
perf record -e cpu-cycles,instructions ls -l
```

This records CPU cycles and instructions for the `ls -l` command.

### 7\. perf stat with duration

You can run `perf stat` for a specific duration using the `-p` option for a process ID or `-a` for all CPUs.

Example:

```
perf stat -a sleep 5
```

This will monitor system-wide performance for 5 seconds.

### 8\. perf annotate

`perf annotate` shows the annotated source code or assembly with performance metrics.

Example:

```
perf record -g ./my_program
perf annotate
```

This displays the annotated performance of `my_program` including which lines consume the most CPU.

### 9\. perf script

`perf script` converts `perf.data` into a more detailed human-readable format.

Example:

```
perf record -g ./my_program
perf script > output.txt
```

The `output.txt` file can then be used for further analysis.

### 10\. perf sched

`perf sched` is used to analyze scheduler events.

Example:

```
perf sched record sleep 1
perf sched latency
```

This provides latency information about tasks scheduled during the recorded time.

## Common Flags

- `-e`: Specify the event(s) to monitor
    
- `-p`: Monitor a specific process by PID
    
- `-a`: Monitor system-wide
    
- `-g`: Capture call graphs
    
- `-o`: Output to a specific file
    
- `-- sleep N`: Monitor for N seconds
    

## Practical Example

Record CPU cycles and instructions for a custom program and analyze it:

```
perf record -e cpu-cycles,instructions -g ./my_program
perf report
perf annotate
```

## Summary

The `perf` command is an essential tool for Linux performance analysis. By combining commands like `perf stat`, `perf record`, `perf report`, and `perf top`, you can identify CPU bottlenecks, memory issues, and optimize software performance effectively.

* * *

* * *

# Linux Time Command Guide

## Introduction

The `time` command in Linux is used to measure the execution time of commands and programs. It provides detailed information about the resources consumed during execution, such as real time, user CPU time, system CPU time, and memory usage.

## Basic Usage

The basic syntax of the `time` command is:

```
time [options] command [arguments]
```

### 1\. Measuring Execution Time

The simplest use of `time` is to measure how long a command takes to execute.

Example:

```
time ls -l
```

This will display the `ls -l` output followed by execution time information:

- Real: Total elapsed time.
    
- User: CPU time spent in user mode.
    
- System: CPU time spent in kernel mode.
    

### 2\. Using Built-in Shell time vs GNU time

Most shells have a built-in `time` command. You can use the full-featured GNU `time` with a leading backslash or specifying the path.

Example:

```
/usr/bin/time ls -l
```

This ensures you are using the GNU version, which has more options.

### 3\. Output Format Customization

GNU `time` allows customization of the output using the `-f` option.

Example:

```
/usr/bin/time -f "Time: %E\nUser CPU: %U\nSystem CPU: %S" ls -l
```

- %E: Elapsed real time (in \[hours:\]minutes:seconds)
    
- %U: User CPU time
    
- %S: System CPU time
    
- %P: CPU percentage
    
- %M: Maximum resident set size (memory usage)
    

### 4\. Time a Script or Program

You can use `time` to measure the execution of scripts or programs.

Example:

```
time ./my_script.sh
```

This will execute `my_script.sh` and display time statistics after completion.

### 5\. Redirecting Output

By default, `time` writes its output to standard error. You can redirect it to a file.

Example:

```
time ls -l 2> time_output.txt
```

This saves the timing information in `time_output.txt`.

### 6\. Measure Multiple Commands

You can use `time` with a group of commands by enclosing them in braces.

Example:

```
time { ls -l; sleep 2; }
```

This measures the total time for both commands.

### 7\. Real, User, and System Time Explained

- Real time (wall clock time): Actual elapsed time from start to finish.
    
- User time: CPU time spent executing user code.
    
- System time: CPU time spent in kernel code.
    

### 8\. Time with Resource Limits

You can combine `time` with `ulimit` to measure execution under resource constraints.

Example:

```
ulimit -t 2
time ./my_script.sh
```

This limits CPU time to 2 seconds for `my_script.sh`.

### 9\. Using Time with Verbose Output

GNU `time` provides a verbose output option with `-v` for detailed resource usage.

Example:

```
/usr/bin/time -v ls -l
```

This provides information including:

- CPU usage
    
- Memory usage
    
- Context switches
    
- I/O statistics
    
- Exit status
    

### 10\. Practical Examples

1.  Measure execution time of a program:

```
time ./my_program
```

2.  Measure time with memory usage details:

```
/usr/bin/time -v ./my_program
```

3.  Measure multiple commands:

```
time { echo Hello; sleep 3; }
```

4.  Redirect output to a file:

```
time ./my_program 2> timing.txt
```

## Summary

The `time` command is a versatile tool to monitor command execution time and resource usage. By using options like `-v` for verbose output or `-f` to customize formats, you can gain detailed insights into performance, CPU utilization, and memory consumption of any program or script.

* * *

* * *

# Linux Top Command Guide

## Introduction

The `top` command in Linux is a real-time system monitoring utility that provides a dynamic view of running processes, CPU usage, memory usage, and system performance. It is commonly used for performance analysis, troubleshooting, and process management.

## Basic Usage

The basic syntax of the `top` command is:

```
top [options]
```

### 1\. Launching top

Simply running `top` without any options displays a dynamic list of processes:

```
top
```

The top interface typically shows:

- System summary (uptime, load average, tasks)
    
- CPU usage (user, system, idle, iowait)
    
- Memory and swap usage
    
- List of processes with PID, user, CPU and memory usage, and command
    

### 2\. Interactive Commands

While `top` is running, you can interact using keyboard commands:

- `h`: Display help
    
- `q`: Quit top
    
- `k`: Kill a process by PID
    
- `r`: Renice a process
    
- `c`: Toggle display of full command line
    
- `M`: Sort processes by memory usage
    
- `P`: Sort processes by CPU usage
    
- `T`: Sort processes by running time
    
- `u`: Show processes of a specific user
    

### 3\. Displaying Specific User Processes

You can filter processes by user:

```
top -u username
```

This shows only the processes owned by `username`.

### 4\. Running top with Batch Mode

Batch mode allows `top` output to be used in scripts or saved to a file:

```
top -b -n 1 > top_output.txt
```

- `-b`: Batch mode
    
- `-n`: Number of iterations
    

### 5\. Adjusting Refresh Interval

You can change the refresh interval with `-d`:

```
top -d 5
```

This updates the display every 5 seconds.

### 6\. Sorting Processes

By default, `top` sorts processes by CPU usage. You can sort by other fields interactively or using options:

- Sort by memory:

```
top -o %MEM
```

- Sort by CPU:

```
top -o %CPU
```

### 7\. Highlighting Running Tasks

You can enable color to highlight important metrics:

```
top -c
```

`-c` shows full command lines which helps in identifying resource-consuming processes.

### 8\. Limiting Number of Processes Displayed

You can limit the number of processes displayed using the `-n` and `-b` options in batch mode, or interactively by pressing `n` in top.

Example:

```
top -b -n 1 | head -n 20
```

This shows only the top 20 lines of output.

### 9\. Monitoring Specific Process

You can focus on a specific PID using `-p`:

```
top -p 1234
```

This shows only the process with PID 1234.

### 10\. Practical Examples

1.  Display top processes sorted by memory:

```
top -o %MEM
```

2.  Show processes for a specific user:

```
top -u sushil
```

3.  Run top in batch mode for reporting:

```
top -b -n 3 > top_report.txt
```

4.  Focus on a single process:

```
top -p 5678
```

5.  Change refresh interval to 10 seconds:

```
top -d 10
```

## Summary

The `top` command is an essential tool for real-time monitoring of system performance in Linux. With its interactive commands, sorting capabilities, and batch mode, `top` allows administrators and developers to identify resource bottlenecks, monitor CPU and memory usage, and manage processes efficiently.

* * *

* * *

# Linux Htop Command Guide

## Introduction

The `htop` command in Linux is an interactive process viewer and system monitor. It provides a more user-friendly interface than `top`, with color-coded output, mouse support, and easy process management. `htop` allows monitoring of CPU, memory, swap, and individual processes in real-time.

## Installation

On most Linux distributions, `htop` is not installed by default. Install it using the package manager:

For Ubuntu/Debian:

```
sudo apt-get install htop
```

For CentOS/RHEL:

```
sudo yum install htop
```

For Fedora:

```
sudo dnf install htop
```

## Basic Usage

The basic syntax is:

```
htop [options]
```

### 1\. Launching htop

Simply run:

```
htop
```

This opens an interactive dashboard showing:

- CPU usage (per core)
    
- Memory and swap usage
    
- Load average and uptime
    
- List of processes with PID, user, CPU%, memory%, and command
    

### 2\. Navigating htop

`htop` supports keyboard and mouse navigation:

- Arrow keys: Move up and down the process list
    
- Page Up / Page Down: Scroll through processes
    
- F1: Help
    
- F2: Setup (configure display and colors)
    
- F3: Search for a process by name
    
- F4: Filter processes
    
- F5: Tree view (hierarchical process view)
    
- F6: Sort by a specific column
    
- F7 / F8: Increase / Decrease priority (nice value)
    
- F9: Kill a process
    
- F10: Quit `htop`
    

### 3\. Sorting Processes

You can sort processes by CPU, memory, time, or any column interactively using F6 or by clicking column headers with the mouse.

### 4\. Process Management

`htop` allows sending signals to processes:

- Select a process and press F9 to kill it.
    
- Choose the signal to send (SIGTERM, SIGKILL, etc.)
    
- You can also renice a process with F7 or F8 to adjust priority.
    

### 5\. Tree View

Press F5 to switch to tree view. This shows parent-child relationships between processes, making it easier to understand process hierarchies.

### 6\. Filtering and Searching

- F3: Search for a process by name or PID.
    
- F4: Filter processes by a keyword to narrow down the display.
    

### 7\. Display Customization

Press F2 to access the setup menu. You can:

- Change color schemes
    
- Customize meters (CPU, memory, swap, network)
    
- Configure columns displayed
    
- Enable/disable various UI elements
    

### 8\. Monitoring Specific User Processes

Use the `-u` option to show only processes of a specific user:

```
htop -u username
```

### 9\. Non-Interactive Mode

`htop` can run in non-interactive mode for scripting or logging purposes:

```
htop -b -n 1 > htop_output.txt
```

- `-b`: Batch mode
    
- `-n`: Number of iterations
    

### 10\. Practical Examples

1.  Launch `htop` and sort by memory usage:

```
htop
```

Then press F6 and select MEM%

2.  Show processes of a specific user:

```
htop -u sushil
```

3.  Kill a process with PID 1234:

```
Select process -> F9 -> SIGKILL
```

4.  View processes in tree view:

```
htop -> F5
```

5.  Save snapshot for reporting:

```
htop -b -n 1 > htop_report.txt
```

## Summary

`htop` is a powerful and interactive tool for monitoring Linux systems. It provides detailed real-time insights into CPU, memory, swap, and processes. With easy navigation, color-coded display, filtering, and process management capabilities, `htop` is preferred over `top` for everyday system administration and performance monitoring.

* * *

* * *

# Linux Vmstat Command Guide

## Introduction

The `vmstat` command in Linux is used to report virtual memory statistics, process, CPU, and I/O activity. It is a useful tool for monitoring system performance, identifying memory bottlenecks, and analyzing system resource usage in real-time or over intervals.

## Basic Usage

The basic syntax of the `vmstat` command is:

```
vmstat [options] [delay [count]]
```

- `delay`: Time interval in seconds between updates.
    
- `count`: Number of updates before exiting.
    

### 1\. Display System Statistics

Running `vmstat` without arguments displays a summary of system performance since the last reboot:

```
vmstat
```

Columns include:

- `procs`: r (running), b (blocked)
    
- `memory`: swpd (virtual memory used), free, buff, cache
    
- `swap`: si (swap in), so (swap out)
    
- `io`: bi (blocks in), bo (blocks out)
    
- `system`: in (interrupts), cs (context switches)
    
- `cpu`: us (user), sy (system), id (idle), wa (IO wait), st (stolen by hypervisor)
    

### 2\. Monitor in Real-Time

You can monitor system statistics in real-time using a delay interval:

```
vmstat 2
```

This updates statistics every 2 seconds until interrupted.

### 3\. Limit Number of Updates

You can specify both interval and count:

```
vmstat 2 5
```

This updates every 2 seconds and prints 5 times before exiting.

### 4\. Display Memory Statistics in Megabytes

```
vmstat -SM
```

`-S M` displays memory statistics in megabytes.

### 5\. Display Active/Inactive Memory

```
vmstat -a
```

The `-a` option shows active and inactive memory pages.

### 6\. Display System Summary Since Boot

```
vmstat -s
```

This displays cumulative counts since system boot, including total memory, swap usage, page faults, and I/O statistics.

### 7\. Display NUMA Memory Statistics

```
vmstat -m
```

Shows memory usage per NUMA node.

### 8\. Monitor Specific Fields

You can use `grep` or `awk` to extract specific fields. For example, to monitor free memory:

```
vmstat 2 | awk '{print $4}'
```

This prints the free memory column every 2 seconds.

### 9\. Practical Examples

1.  Monitor CPU and memory every 3 seconds for 10 iterations:

```
vmstat 3 10
```

2.  Display memory usage in megabytes:

```
vmstat -SM
```

3.  Show active and inactive memory pages:

```
vmstat -a 2 5
```

4.  Get system summary since boot:

```
vmstat -s
```

5.  Monitor disk I/O activity:

```
vmstat 2 5
```

Focus on `bi` and `bo` columns.

### 10\. Understanding Columns

- `r`: Processes waiting for CPU
    
- `b`: Processes in uninterruptible sleep
    
- `swpd`: Virtual memory used
    
- `free`: Idle memory
    
- `buff`: Memory used as buffers
    
- `cache`: Memory used as cache
    
- `si`: Memory swapped in from disk
    
- `so`: Memory swapped out to disk
    
- `bi`: Blocks received from block device
    
- `bo`: Blocks sent to block device
    
- `in`: Number of interrupts per second
    
- `cs`: Number of context switches per second
    
- `us`: Time spent running non-kernel code
    
- `sy`: Time spent running kernel code
    
- `id`: Time spent idle
    
- `wa`: Time waiting for I/O
    
- `st`: Time stolen by hypervisor
    

## Summary

`vmstat` is a powerful tool for monitoring system performance, providing insights into CPU, memory, swap, and I/O activity. By combining interval and count parameters, you can monitor system activity in real-time or analyze historical statistics to troubleshoot performance issues effectively.

* * *

* * *

# Linux Iostat Command Guide

## Introduction

The `iostat` command in Linux is used to monitor system input/output (I/O) device loading. It provides detailed statistics for CPU utilization, device I/O, and partitions. `iostat` is part of the `sysstat` package and is helpful for identifying performance bottlenecks related to storage devices.

## Installation

Install `iostat` via the package manager if not already available:

For Ubuntu/Debian:

```
sudo apt-get install sysstat
```

For CentOS/RHEL:

```
sudo yum install sysstat
```

For Fedora:

```
sudo dnf install sysstat
```

Enable `sysstat` service to collect statistics:

```
sudo systemctl enable sysstat
sudo systemctl start sysstat
```

## Basic Usage

The basic syntax of `iostat` is:

```
iostat [options] [interval [count]]
```

- `interval`: Time in seconds between reports.
    
- `count`: Number of reports to generate.
    

### 1\. Display CPU and I/O Statistics

```
iostat
```

This provides a summary of CPU usage and I/O statistics for each device since boot.

### 2\. Display Statistics at Intervals

```
iostat 2 5
```

This updates every 2 seconds and prints 5 reports.

### 3\. Display Device Utilization Only

```
iostat -d
```

This shows statistics for storage devices only, excluding CPU usage.

### 4\. Display Extended Statistics

```
iostat -x
```

The `-x` option provides extended statistics including:

- `rrqm/s`: Read requests merged per second
    
- `wrqm/s`: Write requests merged per second
    
- `r/s`: Read requests per second
    
- `w/s`: Write requests per second
    
- `rMB/s`: Read throughput in MB/s
    
- `wMB/s`: Write throughput in MB/s
    
- `avgrq-sz`: Average request size
    
- `avgqu-sz`: Average queue length
    
- `await`: Average wait time per request
    
- `svctm`: Average service time
    
- `%util`: Percentage of CPU time spent doing I/O
    

### 5\. Display Statistics for Specific Devices

```
iostat -d sda sdb
```

This shows statistics for devices `sda` and `sdb` only.

### 6\. Display CPU Statistics Only

```
iostat -c
```

Shows CPU usage in terms of user, system, idle, and I/O wait.

### 7\. Report in Human-Readable Units

```
iostat -m
```

`-m` reports statistics in megabytes instead of kilobytes.

### 8\. Combine Options

```
iostat -x -d 2 3
```

Displays extended device statistics every 2 seconds for 3 iterations.

### 9\. Practical Examples

1.  Monitor CPU and device I/O every 5 seconds for 10 times:

```
iostat 5 10
```

2.  Show extended statistics for a specific device:

```
iostat -x -p sda 2 3
```

3.  Display CPU statistics only:

```
iostat -c 2 5
```

4.  Show device statistics in megabytes:

```
iostat -d -m 3
```

### 10\. Understanding Key Columns

- `tps`: Transactions per second
    
- `kB_read/s` or `rMB/s`: Read throughput
    
- `kB_wrtn/s` or `wMB/s`: Write throughput
    
- `rrqm/s`, `wrqm/s`: Merged requests per second
    
- `await`: Average time for I/O requests
    
- `svctm`: Average service time per request
    
- `%util`: Percentage of time the device was active
    

## Summary

`iostat` is an essential tool for monitoring storage and CPU performance in Linux. By analyzing CPU usage, device throughput, I/O wait times, and device utilization, administrators can identify bottlenecks, optimize disk performance, and ensure system efficiency. Using interval and count options, you can monitor real-time activity or generate reports for analysis.

* * *

* * *

# Linux SAR Command Guide

## Introduction

The `sar` (System Activity Reporter) command in Linux is part of the `sysstat` package and is used for collecting, reporting, and saving system activity information. It provides detailed insights into CPU, memory, I/O, network, and other performance metrics over time, making it useful for performance monitoring and historical analysis.

## Installation

Install `sar` via the package manager if it is not already available:

For Ubuntu/Debian:

```
sudo apt-get install sysstat
```

For CentOS/RHEL:

```
sudo yum install sysstat
```

For Fedora:

```
sudo dnf install sysstat
```

Enable and start the `sysstat` service to collect statistics:

```
sudo systemctl enable sysstat
sudo systemctl start sysstat
```

## Basic Usage

The basic syntax of the `sar` command is:

```
sar [options] [interval] [count]
```

- `interval`: Time in seconds between reports.
    
- `count`: Number of reports to generate.
    

### 1\. Display CPU Usage

```
sar -u 2 5
```

- `-u`: Reports CPU usage
    
- Updates every 2 seconds for 5 times  
    Columns include `%user`, `%system`, `%iowait`, `%idle`, etc.
    

### 2\. Display Memory Usage

```
sar -r 2 5
```

- `-r`: Reports memory usage statistics
    
- Columns include kbmemfree, kbmemused, %memused, kbbuffers, kbcached, kbcommit, %commit
    

### 3\. Display Swap Usage

```
sar -S 2 5
```

- `-S`: Reports swap usage statistics
    
- Columns include kbswpfree, kbswpused, %swpused, kbswpcad
    

### 4\. Display Device I/O Statistics

```
sar -d 2 5
```

- `-d`: Reports I/O statistics for devices
    
- Columns include tps (transactions per second), rd_sec/s, wr_sec/s, etc.
    

### 5\. Display Network Statistics

```
sar -n DEV 2 5
```

- `-n DEV`: Reports network device statistics
    
- Columns include rxpck/s, txpck/s, rxkB/s, txkB/s, etc.
    

### 6\. Display Context Switches and Interrupts

```
sar -w 2 5
```

- `-w`: Reports task switching and system calls
    
- Columns include cswch/s (context switches), etc.
    

### 7\. Display Load Average

```
sar -q 2 5
```

- `-q`: Reports run queue and load average
    
- Columns include runq-sz, plist-sz, ldavg-1, ldavg-5, ldavg-15, blocked
    

### 8\. Display All Metrics at Once

```
sar -A 2 5
```

- `-A`: Displays all available system metrics

### 9\. Display Historical Data

`sar` stores historical data in `/var/log/sysstat/` by default. You can view past records using the `-f` option:

```
sar -u -f /var/log/sysstat/sa24
```

This displays CPU usage for the 24th day of the month.

### 10\. Practical Examples

1.  Monitor CPU usage every 3 seconds for 10 intervals:

```
sar -u 3 10
```

2.  Check memory usage over time:

```
sar -r 2 5
```

3.  View I/O activity for devices:

```
sar -d 2 5
```

4.  Display network statistics:

```
sar -n DEV 2 5
```

5.  Analyze historical CPU data:

```
sar -u -f /var/log/sysstat/sa15
```

### 11\. Understanding Key Columns

- `%user`: CPU time spent in user mode
    
- `%system`: CPU time spent in kernel mode
    
- `%iowait`: CPU time waiting for I/O
    
- `%idle`: CPU idle time
    
- kbmemfree/kbmemused: Free and used memory in kilobytes
    
- kbbuffers/kbcached: Memory used for buffers and cache
    
- tps: I/O transactions per second
    
- rd_sec/s, wr_sec/s: Read and write throughput per second
    
- rxpck/s, txpck/s: Network packets received/sent per second
    
- runq-sz: Number of processes in run queue
    
- ldavg-1/5/15: Load average over 1, 5, and 15 minutes
    

## Summary

`sar` is a powerful and flexible tool for monitoring and analyzing system performance in Linux. By providing CPU, memory, I/O, network, and process activity statistics, both in real-time and historically, it allows administrators to diagnose performance issues, identify bottlenecks, and plan for capacity requirements.

* * *

* * *

# Linux Atop Command Guide

## Introduction

The `atop` command in Linux is an advanced system and process monitoring tool. It provides detailed real-time and historical information on CPU, memory, disk, network, and process-level resource usage. Unlike `top` and `htop`, `atop` logs system activity over time, which allows administrators to analyze past system performance.

## Installation

Install `atop` using the package manager:

For Ubuntu/Debian:

```
sudo apt-get install atop
```

For CentOS/RHEL:

```
sudo yum install atop
```

For Fedora:

```
sudo dnf install atop
```

Enable and start logging for historical monitoring:

```
sudo systemctl enable atop
sudo systemctl start atop
```

## Basic Usage

The basic syntax of `atop` is:

```
atop [options]
```

### 1\. Launch Atop

Simply run:

```
atop
```

This opens a dynamic real-time display showing:

- CPU usage per core
    
- Memory usage
    
- Disk read/write activity
    
- Network statistics
    
- Active processes with resource consumption
    

### 2\. Interactive Keyboard Shortcuts

While `atop` is running:

- `h`: Help
    
- `q`: Quit
    
- `c`: Show CPU utilization per core
    
- `m`: Show memory usage
    
- `d`: Show disk activity
    
- `n`: Show network activity
    
- `t`: Sort processes by CPU usage
    
- `M`: Sort processes by memory usage
    
- `D`: Sort processes by disk usage
    
- `N`: Sort processes by network usage
    

### 3\. Historical Monitoring

`atop` records system activity in `/var/log/atop/` by default. You can view historical data:

```
atop -r /var/log/atop/atop_20260124
```

Use arrow keys or `t` to navigate through time.

### 4\. Interval and Count

You can run `atop` in interval mode to log snapshots periodically:

```
atop 10 5
```

- `10`: interval in seconds
    
- `5`: number of snapshots
    

### 5\. Process-Level Statistics

`atop` provides detailed information about individual processes including:

- PID, command name, user
    
- CPU%, memory%, disk I/O, and network I/O
    
- Thread-level statistics
    

### 6\. Disk and Network Monitoring

- Press `d` to view per-device disk activity (read/write per second)
    
- Press `n` to view network traffic per interface (bytes sent/received)
    

### 7\. Filter by Process or User

You can filter processes by user or PID:

```
atop -u username
```

or

```
atop -P 1234
```

This shows only processes belonging to `username` or PID `1234`.

### 8\. Log Files for Reporting

`atop` automatically creates daily log files. Use these logs for generating reports or analyzing past performance:

```
atop -r /var/log/atop/atop_20260124 > report.txt
```

### 9\. Practical Examples

1.  Launch `atop` in real-time:

```
atop
```

2.  Monitor CPU, memory, and I/O every 10 seconds for 5 intervals:

```
atop 10 5
```

3.  View historical data for a specific day:

```
atop -r /var/log/atop/atop_20260120
```

4.  Filter processes by a specific user:

```
atop -u sushil
```

5.  Save report from historical logs:

```
atop -r /var/log/atop/atop_20260124 > system_report.txt
```

### 10\. Understanding Key Sections

- CPU Section: shows user, system, nice, idle, and I/O wait percentages
    
- Memory Section: shows free, used, cache, and buffer memory
    
- Disk Section: shows read/write throughput and service time
    
- Network Section: shows bytes sent/received per interface
    
- Process Section: shows resource usage per process including CPU, memory, disk, and network
    

## Summary

`atop` is a comprehensive monitoring tool for Linux systems. It offers real-time and historical insights into system resources at both the system and process levels. With features like detailed CPU, memory, disk, and network monitoring, along with logging capabilities, `atop` is ideal for performance analysis, troubleshooting, and capacity planning.

* * *

* * *

&nbsp;
