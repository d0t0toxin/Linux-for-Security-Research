***
**Build Tools:** `make`, `cmake`, `ninja`, `gradle`, `maven`, `ant`, `docker build`
***
***
# `make` Command in Linux

## Introduction

The `make` command in Linux is a build automation tool that automatically builds executable programs and libraries from source code by reading files called `Makefiles`. It is widely used in software development to manage dependencies and simplify the compilation process.

## Makefile Structure

A `Makefile` contains rules, dependencies, and commands. The general syntax is:

```
target: dependencies
    command
```

- **target**: The file or action to build (e.g., executable, object file)
    
- **dependencies**: Files needed to create the target
    
- **command**: Shell commands to build the target (must start with a tab)
    

## Basic Examples

### Example 1: Simple Compilation

Makefile:

```
all: hello

hello: hello.o
    gcc -o hello hello.o

hello.o: hello.c
    gcc -c hello.c

clean:
    rm -f hello hello.o
```

Commands:

```
make        # builds hello
make clean  # removes compiled files
```

### Example 2: Using Variables

Makefile:

```
CC = gcc
CFLAGS = -Wall

all: program

program: main.o utils.o
    $(CC) $(CFLAGS) -o program main.o utils.o

main.o: main.c
    $(CC) $(CFLAGS) -c main.c

utils.o: utils.c
    $(CC) $(CFLAGS) -c utils.c

clean:
    rm -f program *.o
```

### Example 3: Pattern Rules

Makefile:

```
CC = gcc
CFLAGS = -Wall

all: app

%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@

app: main.o helper.o
    $(CC) $(CFLAGS) -o app main.o helper.o

clean:
    rm -f app *.o
```

- `$<` represents the first dependency
    
- `$@` represents the target
    

## Common Make Command Options

### 1\. make

Builds the first target in the Makefile.

```
make
```

### 2\. make target

Builds a specific target defined in the Makefile.

```
make clean   # Executes the clean target
make all     # Builds all target
```

### 3\. make -f filename

Specifies a custom Makefile instead of the default `Makefile`.

```
make -f MyMakefile
```

### 4\. make clean

Runs a custom clean target to remove compiled files.

```
make clean
```

### 5\. make -j N

Runs multiple jobs in parallel to speed up compilation.

```
make -j 4   # Executes 4 jobs simultaneously
```

### 6\. make -n

Shows the commands that would be executed without actually running them.

```
make -n
```

### 7\. make -k

Keeps going as much as possible after an error.

```
make -k
```

### 8\. make -B

Forces all targets to be rebuilt regardless of timestamps.

```
make -B
```

### 9\. make -C directory

Changes to the specified directory before reading the Makefile.

```
make -C src
```

### 10\. make -s

Runs silently without printing command lines.

```
make -s
```

### 11\. make -q

Checks if the target is up to date; returns 0 if it is, 1 otherwise.

```
make -q
```

### 12\. make --help

Displays all available options for the `make` command.

```
make --help
```

## Advanced Concepts

### Phony Targets

These are targets not associated with actual files, usually for commands like `clean`.

```
.PHONY: clean all
```

### Conditional Statements

```
CC = gcc
ifeq ($(CC),gcc)
    CFLAGS = -O2
else
    CFLAGS = -g
endif
```

### Including Other Makefiles

```
include common.mk
```

### Automatic Variables

- `$@` : target name
    
- `$^` : all dependencies
    
- `$<` : first dependency
    

## Conclusion

The `make` command is a powerful tool for managing builds, handling dependencies, and automating compilation processes. Proper use of Makefiles and command options can save time and reduce errors in software projects.

* * *

* * *

